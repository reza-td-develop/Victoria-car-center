import { j as Rt } from "./index-b2203153.js";
import * as n from "react";
import { forwardRef as wt, useReducer as Tt, useImperativeHandle as St } from "react";
import * as Mt from "react-dom";
import "styled-components";
const Qe = "carousel", Ne = "controller", yt = "core", Ft = "navigation", kt = "no-scroll", Ze = "portal", Je = "toolbar", At = "captions", xe = "fullscreen", Be = "thumbnails", ve = "loading", _e = "error", le = "complete", Dt = "placeholder", Bt = (e) => `active-slide-${e}`, et = "backdrop_click", tt = "fullsize", nt = "flex_center", Ht = "no_scroll", ot = "no_scroll_padding", z = "prev", G = "next", K = "close", rt = "onPointerDown", st = "onPointerMove", ct = "onPointerUp", lt = "onPointerLeave", it = "onPointerCancel", at = "onKeyDown", ut = "onKeyUp", dt = "onWheel", Vt = "Escape", Xt = "ArrowLeft", $t = "ArrowRight", Wt = "button", Oe = "icon", ft = "contain", He = "cover", mt = {
  open: !1,
  close: () => {
  },
  index: 0,
  slides: [],
  render: {},
  plugins: [],
  toolbar: { buttons: [K] },
  labels: {},
  animation: {
    fade: 330,
    swipe: 500
  },
  carousel: {
    finite: !1,
    preload: 2,
    padding: "16px",
    spacing: "30%",
    imageFit: ft
  },
  controller: {
    focus: !0,
    aria: !1,
    touchAction: "none",
    closeOnBackdropClick: !1
  },
  on: {},
  styles: {},
  className: ""
}, k = (...e) => [...e].filter((t) => Boolean(t)).join(" "), ht = "yarl__", O = (e) => `${ht}${e}`, M = (e) => `--${ht}${e}`, re = (e, t) => `${e}${t ? `_${t}` : ""}`, Pe = (e) => (t) => re(e, t), ae = (e, t) => e && e[t] ? e[t] : t, Et = (...e) => () => {
  e.forEach((t) => {
    t();
  });
}, ee = (e, t, o) => () => {
  const r = n.useContext(o);
  if (!r)
    throw new Error(`${e} must be used within a ${t}.Provider`);
  return r;
}, pt = () => typeof window < "u", Re = (e) => typeof e < "u", ie = (e) => typeof e == "number", Ut = (e) => !Re(e.type) || e.type === "image", Le = (e) => {
  if (typeof e == "number")
    return { pixel: e };
  if (typeof e == "string") {
    const t = parseInt(e, 10);
    return e.endsWith("%") ? { percent: t } : { pixel: t };
  }
  return { pixel: 0 };
}, D = (e, t) => ({
  name: e,
  component: t
}), R = (e, t) => ({
  module: e,
  children: t
}), vt = (e, t, o) => e.module.name === t ? o(e) : e.children ? [
  R(e.module, e.children.flatMap((r) => {
    var s;
    return (s = vt(r, t, o)) !== null && s !== void 0 ? s : [];
  }))
] : [e], Z = (e, t, o) => e.flatMap((r) => {
  var s;
  return (s = vt(r, t, o)) !== null && s !== void 0 ? s : [];
}), zt = (e, t) => {
  let o = e;
  const r = [], s = (u) => {
    const m = [...o];
    for (; m.length > 0; ) {
      const h = m.pop();
      if ((h == null ? void 0 : h.module.name) === u)
        return !0;
      h != null && h.children && m.push(...h.children);
    }
    return !1;
  }, c = (u, m) => {
    if (u === "") {
      o = [R(m, o)];
      return;
    }
    o = Z(o, u, (h) => [R(m, [h])]);
  }, l = (u, m) => {
    o = Z(o, u, (h) => [R(h.module, [R(m, h.children)])]);
  }, d = (u, m, h) => {
    o = Z(o, u, (v) => {
      var b;
      return [
        R(v.module, [
          ...h ? [R(m)] : [],
          ...(b = v.children) !== null && b !== void 0 ? b : [],
          ...h ? [] : [R(m)]
        ])
      ];
    });
  }, i = (u, m, h) => {
    o = Z(o, u, (v) => [
      ...h ? [R(m)] : [],
      v,
      ...h ? [] : [R(m)]
    ]);
  }, _ = (u, m) => {
    o = Z(o, u, (h) => [R(m, h.children)]);
  }, E = (u) => {
    o = Z(o, u, (m) => m.children);
  }, p = (u) => {
    r.push(u);
  };
  return t == null || t.forEach((u) => {
    u({
      contains: s,
      addParent: c,
      append: l,
      addChild: d,
      addSibling: i,
      replace: _,
      remove: E,
      augment: p
    });
  }), {
    config: o,
    augmentation: (u) => r.reduce((m, h) => h(m), u)
  };
}, we = () => {
  const [e, t] = n.useState(), o = n.useRef(null), r = n.useRef(), s = n.useCallback((c) => {
    o.current = c, r.current && (r.current.disconnect(), r.current = void 0);
    const l = () => {
      if (c) {
        const d = window.getComputedStyle(c), i = (_) => parseFloat(_) || 0;
        t({
          width: Math.round(c.clientWidth - i(d.paddingLeft) - i(d.paddingRight)),
          height: Math.round(c.clientHeight - i(d.paddingTop) - i(d.paddingBottom))
        });
      } else
        t(void 0);
    };
    l(), c && typeof ResizeObserver < "u" && (r.current = new ResizeObserver(l), r.current.observe(c));
  }, []);
  return n.useMemo(() => ({
    setContainerRef: s,
    containerRef: o,
    containerRect: e
  }), [s, o, e]);
}, ue = pt() ? n.useLayoutEffect : n.useEffect, P = (e) => {
  const t = n.useRef(e);
  return ue(() => {
    t.current = e;
  }), n.useCallback((...o) => {
    var r;
    return (r = t.current) === null || r === void 0 ? void 0 : r.call(t, ...o);
  }, []);
}, Ve = (e, t) => {
  typeof e == "function" ? e(t) : e && (e.current = t);
}, Xe = (e, t) => n.useMemo(() => e == null && t == null ? null : (o) => {
  Ve(e, o), Ve(t, o);
}, [e, t]), _t = () => {
  const [e, t] = n.useState(!1);
  return n.useEffect(() => {
    var o, r;
    const s = (o = window.matchMedia) === null || o === void 0 ? void 0 : o.call(window, "(prefers-reduced-motion: reduce)");
    t(s == null ? void 0 : s.matches);
    const c = (l) => t(l.matches);
    return (r = s == null ? void 0 : s.addEventListener) === null || r === void 0 || r.call(s, "change", c), () => {
      var l;
      return (l = s == null ? void 0 : s.removeEventListener) === null || l === void 0 ? void 0 : l.call(s, "change", c);
    };
  }, []), e;
}, Te = () => {
  const [e, t] = n.useState(!1);
  return ue(() => {
    t(window.getComputedStyle(window.document.documentElement).direction === "rtl");
  }, []), e;
}, Gt = () => {
  const [e] = n.useState({});
  return n.useMemo(() => {
    const t = (o, r) => {
      var s;
      (s = e[o]) === null || s === void 0 || s.forEach((c) => {
        r.isPropagationStopped() || c(r);
      });
    };
    return {
      registerSensors: {
        onPointerDown: (o) => t(rt, o),
        onPointerMove: (o) => t(st, o),
        onPointerUp: (o) => t(ct, o),
        onPointerLeave: (o) => t(lt, o),
        onPointerCancel: (o) => t(it, o),
        onKeyDown: (o) => t(at, o),
        onKeyUp: (o) => t(ut, o),
        onWheel: (o) => t(dt, o)
      },
      subscribeSensors: (o, r) => (e[o] || (e[o] = []), e[o].unshift(r), () => {
        const s = e[o];
        s && s.splice(0, s.length, ...s.filter((c) => c !== r));
      })
    };
  }, [e]);
}, gt = n.createContext(null), q = ee("useEvents", "EventsContext", gt), Yt = ({ children: e }) => {
  const [t] = n.useState({});
  n.useEffect(() => () => {
    Object.keys(t).forEach((r) => delete t[r]);
  }, [t]);
  const o = n.useMemo(() => {
    const r = (l, d) => {
      t[l] && (t[l] = t[l].filter((i) => i !== d));
    };
    return { publish: (l, d) => {
      var i;
      (i = t[l]) === null || i === void 0 || i.forEach((_) => _(d));
    }, subscribe: (l, d) => (t[l] || (t[l] = []), t[l].push(d), () => r(l, d)), unsubscribe: r };
  }, [t]);
  return n.createElement(gt.Provider, { value: o }, e);
}, Ct = n.createContext(null), de = ee("useLightboxState", "LightboxStateContext", Ct), Kt = (e) => (t, o) => {
  var r;
  return o.increment !== void 0 || o.animationDuration !== void 0 ? {
    currentIndex: ((t.currentIndex + (o.increment || 0)) % e + e) % e,
    globalIndex: t.globalIndex + (o.increment || 0),
    animationDuration: (r = o.animationDuration) !== null && r !== void 0 ? r : t.animationDuration
  } : t;
}, qt = ({ initialIndex: e, slidesCount: t, children: o }) => {
  const [r, s] = n.useReducer(Kt(t), {
    currentIndex: e,
    globalIndex: e,
    animationDuration: 0
  }), c = n.useMemo(() => ({ state: r, dispatch: s }), [r, s]);
  return n.createElement(Ct.Provider, { value: c }, o);
}, bt = n.createContext(null), Se = ee("useTimeouts", "TimeoutsContext", bt), jt = ({ children: e }) => {
  const [t] = n.useState([]);
  n.useEffect(() => () => {
    t.forEach((r) => window.clearTimeout(r)), t.splice(0, t.length);
  }, [t]);
  const o = n.useMemo(() => {
    const r = (l) => {
      t.splice(0, t.length, ...t.filter((d) => d !== l));
    };
    return { setTimeout: (l, d) => {
      const i = window.setTimeout(() => {
        r(i), l();
      }, d);
      return t.push(i), i;
    }, clearTimeout: (l) => {
      Re(l) && (r(l), window.clearTimeout(l));
    } };
  }, [t]);
  return n.createElement(bt.Provider, { value: o }, e);
}, Qt = (e, t, o, r, s, c, l, d) => {
  const i = n.useRef(0), _ = n.useRef([]), E = n.useRef(), p = n.useRef(0), u = n.useCallback((a) => {
    E.current === a.pointerId && (E.current = void 0);
    const f = _.current;
    f.splice(0, f.length, ...f.filter((C) => C.pointerId !== a.pointerId));
  }, []), m = n.useCallback((a) => {
    u(a), a.persist(), _.current.push(a);
  }, [u]), h = P((a) => {
    m(a);
  }), v = P((a) => {
    if (_.current.find((f) => f.pointerId === a.pointerId) && E.current === a.pointerId) {
      const f = Date.now() - p.current, C = i.current;
      Math.abs(C) > 0.3 * o || Math.abs(C) > 5 && f < r ? l(C, f) : d(C), i.current = 0;
    }
    u(a);
  }), b = P((a) => {
    const f = _.current.find((C) => C.pointerId === a.pointerId);
    if (f) {
      const C = E.current === a.pointerId;
      if (a.buttons === 0) {
        C && i.current !== 0 ? v(a) : u(f);
        return;
      }
      const I = a.clientX - f.clientX, T = a.clientY - f.clientY;
      E.current === void 0 && t(I) && Math.abs(I) > Math.abs(T) && Math.abs(I) > 30 ? (m(a), E.current = a.pointerId, p.current = Date.now(), s()) : C && (i.current = I, c(I));
    }
  });
  n.useEffect(() => Et(e(rt, h), e(st, b), e(ct, v), e(lt, v), e(it, v)), [e, h, b, v]);
}, $e = "wheel", We = (e) => {
  (Math.abs(e.deltaX) > Math.abs(e.deltaY) || e.ctrlKey) && e.preventDefault();
}, Zt = () => {
  const e = n.useRef(null);
  return n.useCallback((t) => {
    var o;
    t ? t.addEventListener($e, We, { passive: !1 }) : (o = e.current) === null || o === void 0 || o.removeEventListener($e, We), e.current = t;
  }, []);
}, Jt = (e, t, o, r, s, c, l, d, i) => {
  const _ = n.useRef(0), E = n.useRef(0), p = n.useRef(), u = n.useRef(), m = n.useRef(0), h = n.useRef(0), { setTimeout: v, clearTimeout: b } = Se(), a = n.useCallback(() => {
    p.current && (b(p.current), p.current = void 0);
  }, [b]), f = n.useCallback(() => {
    u.current && (b(u.current), u.current = void 0);
  }, [b]), C = P(() => {
    e !== F.SWIPE && (_.current = 0, h.current = 0, a(), f());
  });
  n.useEffect(C, [e, C]);
  const I = P((x) => {
    u.current = void 0, _.current === x && i(_.current);
  }), T = P((x) => {
    if (!x.ctrlKey && !(Math.abs(x.deltaY) > Math.abs(x.deltaX)))
      if (e)
        if (e === F.SWIPE) {
          let N = _.current - x.deltaX;
          if (N = Math.min(Math.abs(N), r) * Math.sign(N), _.current = N, l(N), f(), Math.abs(N) > 0.2 * r) {
            m.current = x.deltaX, d(N, Date.now() - h.current);
            return;
          }
          u.current = v(() => I(N), 2 * s);
        } else
          m.current = x.deltaX;
      else {
        if (Math.abs(x.deltaX) <= 1.2 * Math.abs(m.current)) {
          m.current = x.deltaX;
          return;
        }
        if (!o(-x.deltaX))
          return;
        if (E.current += x.deltaX, a(), Math.abs(E.current) > 30)
          E.current = 0, m.current = 0, h.current = Date.now(), c();
        else {
          const N = E.current;
          p.current = v(() => {
            p.current = void 0, N === E.current && (E.current = 0);
          }, s);
        }
      }
  });
  n.useEffect(() => t(dt, T), [t, T]);
};
var F;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.SWIPE = 1] = "SWIPE", e[e.ANIMATION = 2] = "ANIMATION";
})(F || (F = {}));
const en = Pe("container"), xt = n.createContext(null), fe = ee("useController", "ControllerContext", xt), tn = ({ children: e, ...t }) => {
  const { carousel: o, slides: r, animation: s, controller: c, on: l, styles: d } = t, { state: i, dispatch: _ } = de(), [E, p] = n.useState(F.NONE), u = n.useRef(0), m = n.useRef(), { registerSensors: h, subscribeSensors: v } = Gt(), { subscribe: b, publish: a } = q(), { setTimeout: f, clearTimeout: C } = Se(), { containerRef: I, setContainerRef: T, containerRect: x } = we(), N = Xe(Zt(), T), w = n.useRef(null), te = Xe(w, void 0), B = n.useRef(), ne = n.useRef(), se = _t(), he = Te(), H = P((g) => (he ? -1 : 1) * (ie(g) ? g : 1)), L = P((g) => !(o.finite && (H(g) > 0 && i.currentIndex === 0 || H(g) < 0 && i.currentIndex === r.length - 1))), Q = n.useCallback((g) => {
    var S;
    u.current = g, (S = I.current) === null || S === void 0 || S.style.setProperty(M("swipe_offset"), `${Math.round(g)}px`);
  }, [I]), oe = P((g) => {
    var S;
    const y = s.swipe, $ = g.offset || 0;
    let { direction: V } = g;
    const W = (S = g.count) !== null && S !== void 0 ? S : 1;
    let ce = F.ANIMATION, A = y * W;
    if (!V) {
      const X = x == null ? void 0 : x.width, De = g.duration || 0, pe = X ? y / X * Math.abs($) : y;
      W !== 0 ? De < pe ? A = A / pe * Math.max(De, pe / 5) : X && (A = y / X * (X - Math.abs($))) : A = y / 2, W !== 0 && (V = H($) > 0 ? z : G);
    }
    let Ee;
    if (V === z ? L(H(1)) ? Ee = -W : (ce = F.NONE, A = y) : V === G && (L(H(-1)) ? Ee = W : (ce = F.NONE, A = y)), w.current && (ne.current = {
      rect: w.current.getBoundingClientRect(),
      index: i.globalIndex
    }), A = Math.round(A), C(m.current), ce) {
      const X = f(() => {
        m.current === X && (Q(0), p(F.NONE));
      }, A);
      m.current = X;
    }
    p(ce), _({ increment: Ee, animationDuration: A });
  }), Nt = P(() => {
    var g, S, y;
    const $ = ne.current;
    if (ne.current = void 0, $ && w.current && x) {
      const V = Le(o.spacing), W = (V.percent ? V.percent * x.width / 100 : V.pixel) || 0;
      (g = B.current) === null || g === void 0 || g.cancel(), B.current = (y = (S = w.current).animate) === null || y === void 0 ? void 0 : y.call(S, [
        {
          transform: `translateX(${H(i.globalIndex - $.index) * (x.width + W) + $.rect.x - w.current.getBoundingClientRect().x}px)`
        },
        { transform: "translateX(0)" }
      ], se ? 0 : i.animationDuration), B.current && (B.current.onfinish = () => {
        B.current = void 0;
      });
    }
  });
  ue(Nt);
  const Me = [
    v,
    L,
    (x == null ? void 0 : x.width) || 0,
    s.swipe,
    () => p(F.SWIPE),
    (g) => Q(g),
    (g, S) => oe({ offset: g, duration: S, count: 1 }),
    (g) => oe({ offset: g, count: 0 })
  ];
  Qt(...Me), Jt(E, ...Me);
  const ye = P(() => {
    var g;
    c.focus && ((g = I.current) === null || g === void 0 || g.focus());
  });
  n.useEffect(ye, [ye]);
  const Fe = P(() => {
    var g;
    (g = l.view) === null || g === void 0 || g.call(l, i.currentIndex);
  });
  n.useEffect(Fe, [i.currentIndex, Fe]), n.useEffect(() => Et(b(z, (g) => oe({
    direction: z,
    count: ie(g) ? g : void 0
  })), b(G, (g) => oe({
    direction: G,
    count: ie(g) ? g : void 0
  }))), [b, oe]), n.useEffect(() => v(ut, (g) => {
    g.code === Vt && a(K);
  }), [v, a]), n.useEffect(() => c.closeOnBackdropClick ? b(et, () => a(K)) : () => {
  }, [c.closeOnBackdropClick, a, b]);
  const ke = P(() => {
    var g;
    return (g = I.current) === null || g === void 0 ? void 0 : g.focus();
  }), Ae = P(() => t), Pt = n.useMemo(() => ({
    getLightboxProps: Ae,
    subscribeSensors: v,
    transferFocus: ke,
    containerRect: x || { width: 0, height: 0 },
    containerRef: I,
    setCarouselRef: te
  }), [Ae, v, ke, x, I, te]);
  return n.createElement("div", { ref: N, className: k(O(en()), O(nt)), style: {
    ...E === F.SWIPE ? { [M("swipe_offset")]: `${Math.round(u.current)}px` } : null,
    ...c.touchAction !== "none" ? { [M("controller_touch_action")]: c.touchAction } : null,
    ...d.container
  }, ...c.aria ? { role: "presentation", "aria-live": "polite" } : null, tabIndex: -1, ...h }, x && n.createElement(xt.Provider, { value: Pt }, e));
}, nn = D(Ne, tn), me = n.forwardRef(({ label: e, className: t, icon: o, renderIcon: r, onClick: s, style: c, ...l }, d) => {
  const { styles: i } = fe().getLightboxProps();
  return n.createElement("button", { ref: d, type: "button", "aria-label": e, className: k(O(Wt), t), onClick: s, style: { ...c, ...i.button }, ...l }, r ? r() : n.createElement(o, { className: O(Oe), style: i.icon }));
});
me.displayName = "IconButton";
const j = (e, t) => {
  const o = (r) => n.createElement(
    "svg",
    { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24", "aria-hidden": "true", focusable: "false", ...r },
    n.createElement(
      "g",
      { fill: "currentColor" },
      n.createElement("path", { d: "M0 0h24v24H0z", fill: "none" }),
      t
    )
  );
  return o.displayName = e, o;
}, on = j("Close", n.createElement("path", { d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" })), rn = j("Previous", n.createElement("path", { d: "M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z" })), sn = j("Next", n.createElement("path", { d: "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z" })), cn = j("Loading", n.createElement(n.Fragment, null, Array.from({ length: 8 }).map((e, t, o) => n.createElement("line", { key: t, x1: "12", y1: "6.5", x2: "12", y2: "1.8", strokeLinecap: "round", strokeWidth: "2.6", stroke: "currentColor", strokeOpacity: 1 / o.length * (t + 1), transform: `rotate(${360 / o.length * t}, 12, 12)` })))), ln = j("Error", n.createElement("path", { d: "M21.9,21.9l-8.49-8.49l0,0L3.59,3.59l0,0L2.1,2.1L0.69,3.51L3,5.83V19c0,1.1,0.9,2,2,2h13.17l2.31,2.31L21.9,21.9z M5,18 l3.5-4.5l2.5,3.01L12.17,15l3,3H5z M21,18.17L5.83,3H19c1.1,0,2,0.9,2,2V18.17z" })), ge = Pe("slide"), Ce = Pe("slide_image"), an = ({ slide: e, offset: t, render: o, rect: r, imageFit: s, onClick: c, onLoad: l, style: d }) => {
  var i, _, E, p, u, m, h;
  const [v, b] = n.useState(ve), { publish: a } = q(), f = n.useRef(null);
  n.useEffect(() => {
    t === 0 && a(Bt(v));
  }, [t, v, a]);
  const C = P((L) => {
    v !== le && ("decode" in L ? L.decode() : Promise.resolve()).catch(() => {
    }).then(() => {
      L.parentNode && (b(le), l == null || l(L));
    });
  }), I = n.useCallback((L) => {
    f.current = L, L != null && L.complete && C(L);
  }, [C]), T = n.useCallback((L) => {
    C(L.currentTarget);
  }, [C]), x = n.useCallback(() => {
    b(_e);
  }, []), N = e.imageFit === He || e.imageFit !== ft && s === He, w = (L, Q) => Number.isFinite(L) ? L : Q, te = w(Math.max(...((_ = (i = e.srcSet) === null || i === void 0 ? void 0 : i.map((L) => L.width)) !== null && _ !== void 0 ? _ : []).concat(e.width ? [e.width] : [])), ((E = f.current) === null || E === void 0 ? void 0 : E.naturalWidth) || 0), B = w(Math.max(...((u = (p = e.srcSet) === null || p === void 0 ? void 0 : p.map((L) => L.height)) !== null && u !== void 0 ? u : []).concat(e.height ? [e.height] : [])), ((m = f.current) === null || m === void 0 ? void 0 : m.naturalHeight) || 0), ne = te && B ? {
    maxWidth: `min(${te}px, 100%)`,
    maxHeight: `min(${B}px, 100%)`
  } : {
    maxWidth: "100%",
    maxHeight: "100%"
  }, se = (h = e.srcSet) === null || h === void 0 ? void 0 : h.sort((L, Q) => L.width - Q.width).map((L) => `${L.src} ${L.width}w`).join(", "), he = () => r && !N && e.width && e.height ? r.height / e.height * e.width : Number.MAX_VALUE, H = se && r && pt() ? `${Math.round(Math.min(he(), r.width))}px` : void 0;
  return n.createElement(
    n.Fragment,
    null,
    n.createElement("img", { ref: I, onLoad: T, onError: x, onClick: c, className: k(O(Ce()), N && O(Ce("cover")), v !== le && O(Ce("loading"))), draggable: !1, alt: e.alt, style: { ...ne, ...d }, sizes: H, srcSet: se, src: e.src }),
    v !== le && n.createElement(
      "div",
      { className: O(ge(Dt)) },
      v === ve && (o != null && o.iconLoading ? o.iconLoading() : n.createElement(cn, { className: k(O(Oe), O(ge(ve))) })),
      v === _e && (o != null && o.iconError ? o.iconError() : n.createElement(ln, { className: k(O(Oe), O(ge(_e))) }))
    )
  );
}, U = (e) => re(Qe, e), Ue = (e) => re("slide", e), be = ({ slide: e, offset: t }) => {
  const { setContainerRef: o, containerRect: r, containerRef: s } = we(), { publish: c } = q(), { state: { currentIndex: l } } = de(), { getLightboxProps: d } = fe(), { render: i, carousel: { imageFit: _ }, on: { click: E } } = d(), p = (m) => {
    var h, v, b, a;
    let f = (h = i.slide) === null || h === void 0 ? void 0 : h.call(i, e, t, m);
    return !f && Ut(e) && (f = n.createElement(an, { slide: e, offset: t, render: i, rect: m, imageFit: _, onClick: t === 0 ? () => E == null ? void 0 : E(l) : void 0 })), f ? n.createElement(
      n.Fragment,
      null,
      (v = i.slideHeader) === null || v === void 0 ? void 0 : v.call(i, e),
      ((b = i.slideContainer) !== null && b !== void 0 ? b : (C, I) => I)(e, f),
      (a = i.slideFooter) === null || a === void 0 ? void 0 : a.call(i, e)
    ) : null;
  }, u = (m) => {
    const h = s.current, v = m.target instanceof HTMLElement ? m.target : void 0;
    v && h && (v === h || Array.from(h.children).find((b) => b === v) && v.classList.contains(O(tt))) && c(et);
  };
  return n.createElement("div", { ref: o, className: k(O(Ue()), t === 0 && O(Ue("current")), O(nt)), onClick: u }, r && p(r));
}, ze = () => n.createElement("div", { className: O("slide") }), un = ({ slides: e, carousel: { finite: t, preload: o, padding: r, spacing: s } }) => {
  const { state: { currentIndex: c, globalIndex: l } } = de(), { setCarouselRef: d } = fe(), i = Le(s), _ = Le(r), E = [];
  if ((e == null ? void 0 : e.length) > 0) {
    for (let p = c - o; p < c; p += 1) {
      const u = l + p - c;
      E.push(!t || p >= 0 ? n.createElement(be, { key: u, slide: e[(p + o * e.length) % e.length], offset: p - c }) : n.createElement(ze, { key: u }));
    }
    E.push(n.createElement(be, { key: l, slide: e[c], offset: 0 }));
    for (let p = c + 1; p <= c + o; p += 1) {
      const u = l + p - c;
      E.push(!t || p <= e.length - 1 ? n.createElement(be, { key: u, slide: e[p % e.length], offset: p - c }) : n.createElement(ze, { key: u }));
    }
  }
  return n.createElement("div", { ref: d, className: k(O(U()), E.length > 0 && O(U("with_slides"))), style: {
    [`${M(U("slides_count"))}`]: E.length,
    [`${M(U("spacing_px"))}`]: i.pixel || 0,
    [`${M(U("spacing_percent"))}`]: i.percent || 0,
    [`${M(U("padding_px"))}`]: _.pixel || 0,
    [`${M(U("padding_percent"))}`]: _.percent || 0
  } }, E);
}, dn = D(Qe, un), fn = ({ slides: e, index: t, children: o }) => n.createElement(
  jt,
  null,
  n.createElement(
    Yt,
    null,
    n.createElement(qt, { slidesCount: e.length, initialIndex: t }, o)
  )
), mn = D(yt, fn), Ge = ({ publish: e, labels: t, label: o, icon: r, renderIcon: s, action: c, disabled: l }) => n.createElement(me, { label: ae(t, o), icon: r, renderIcon: s, className: O(`navigation_${c}`), disabled: l, "aria-disabled": l, onClick: () => {
  e(c);
} }), hn = ({ slides: e, carousel: { finite: t }, labels: o, render: { buttonPrev: r, buttonNext: s, iconPrev: c, iconNext: l } }) => {
  const { state: { currentIndex: d } } = de(), { subscribeSensors: i } = fe(), { publish: _ } = q(), E = Te(), p = P((u) => {
    u.key === Xt ? _(E ? G : z) : u.key === $t && _(E ? z : G);
  });
  return n.useEffect(() => i(at, p), [i, p]), n.createElement(
    n.Fragment,
    null,
    r ? r() : n.createElement(Ge, { label: "Previous", action: z, icon: rn, renderIcon: c, disabled: e.length === 0 || t && d === 0, labels: o, publish: _ }),
    s ? s() : n.createElement(Ge, { label: "Next", action: G, icon: sn, renderIcon: l, disabled: e.length === 0 || t && d === e.length - 1, labels: o, publish: _ })
  );
}, En = D(Ft, hn), Ye = O(Ht), pn = O(ot), vn = (e) => "style" in e, Ke = (e, t, o) => {
  const r = window.getComputedStyle(e), s = o ? "padding-left" : "padding-right", c = o ? r.paddingLeft : r.paddingRight, l = e.style.getPropertyValue(s);
  return e.style.setProperty(s, `${(parseInt(c, 10) || 0) + t}px`), () => {
    l ? e.style.setProperty(s, l) : e.style.removeProperty(s);
  };
}, _n = ({ children: e }) => {
  const t = Te();
  return ue(() => {
    const o = [], { body: r, documentElement: s } = document, c = Math.round(window.innerWidth - s.clientWidth);
    if (c > 0) {
      o.push(Ke(r, c, t));
      const l = r.getElementsByTagName("*");
      for (let d = 0; d < l.length; d += 1) {
        const i = l[d];
        vn(i) && window.getComputedStyle(i).getPropertyValue("position") === "fixed" && !i.classList.contains(pn) && o.push(Ke(i, c, t));
      }
    }
    return r.classList.add(Ye), () => {
      r.classList.remove(Ye), o.forEach((l) => l());
    };
  }, [t]), n.createElement(n.Fragment, null, e);
}, gn = D(kt, _n), qe = (e) => re(Ze, e), je = (e, t, o) => {
  const r = e.getAttribute(t);
  return e.setAttribute(t, o), () => {
    r ? e.setAttribute(t, r) : e.removeAttribute(t);
  };
}, Cn = ({ children: e, animation: t, styles: o, className: r, on: s, close: c }) => {
  const [l, d] = n.useState(!1), [i, _] = n.useState(!1), E = n.useRef([]), { setTimeout: p } = Se(), { subscribe: u } = q(), m = _t() ? 0 : t.fade;
  n.useEffect(() => (d(!0), () => {
    d(!1), _(!1);
  }), []);
  const h = P(() => {
    var f;
    _(!1), (f = s.exiting) === null || f === void 0 || f.call(s), p(() => {
      var C;
      (C = s.exited) === null || C === void 0 || C.call(s), c();
    }, m);
  });
  n.useEffect(() => u(K, h), [u, h]);
  const v = P((f) => {
    var C, I, T;
    f.scrollTop, _(!0), (C = s.entering) === null || C === void 0 || C.call(s);
    const x = (T = (I = f.parentNode) === null || I === void 0 ? void 0 : I.children) !== null && T !== void 0 ? T : [];
    for (let N = 0; N < x.length; N += 1) {
      const w = x[N];
      ["TEMPLATE", "SCRIPT", "STYLE"].indexOf(w.tagName) === -1 && w !== f && (E.current.push(je(w, "inert", "true")), E.current.push(je(w, "aria-hidden", "true")));
    }
    p(() => {
      var N;
      (N = s.entered) === null || N === void 0 || N.call(s);
    }, m);
  }), b = P(() => {
    E.current.forEach((f) => f()), E.current = [];
  }), a = n.useCallback((f) => {
    f ? v(f) : b();
  }, [v, b]);
  return l ? Mt.createPortal(n.createElement("div", { ref: a, className: k(r, O("root"), O(qe()), O(ot), i && O(qe("open"))), role: "presentation", "aria-live": "polite", style: {
    ...t.fade !== mt.animation.fade ? {
      [M("fade_animation_duration")]: `${m}ms`
    } : null,
    ...o.root
  } }, e), document.body) : null;
}, bn = D(Ze, Cn), xn = (e) => re(Je, e), On = ({ toolbar: { buttons: e }, labels: t, render: { buttonClose: o, iconClose: r } }) => {
  const { publish: s } = q(), { setContainerRef: c, containerRect: l } = we();
  n.useEffect(() => {
    l != null && l.width && s("toolbar-width", l.width);
  }, [s, l == null ? void 0 : l.width]);
  const d = () => o ? o() : n.createElement(me, { key: K, label: ae(t, "Close"), icon: on, renderIcon: r, onClick: () => s(K) });
  return n.createElement("div", { ref: c, className: O(xn()) }, e == null ? void 0 : e.map((i) => i === K ? d() : i));
}, Ln = D(Je, On), Ot = (e, t) => {
  var o;
  return n.createElement(e.module.component, { key: e.module.name, ...t }, (o = e.children) === null || o === void 0 ? void 0 : o.map((r) => Ot(r, t)));
}, In = (e) => {
  const { carousel: t, animation: o, render: r, toolbar: s, controller: c, on: l, plugins: d, ...i } = e, { carousel: _, animation: E, render: p, toolbar: u, controller: m, on: h, ...v } = mt, { config: b, augmentation: a } = zt([
    R(bn, [
      R(gn, [
        R(nn, [
          R(dn),
          R(Ln),
          R(En)
        ])
      ])
    ])
  ], d), f = a({
    carousel: { ..._, ...t },
    animation: { ...E, ...o },
    render: { ...p, ...r },
    toolbar: { ...u, ...s },
    controller: { ...m, ...c },
    on: { ...h, ...l },
    ...v,
    ...i
  });
  return f.open ? n.createElement(n.Fragment, null, Ot(R(mn, b), f)) : null;
}, Nn = In;
var Y = /* @__PURE__ */ ((e) => (e.LIGHT_BOX_OPEN = "LIGHT_BOX_OPEN", e.LIGHT_BOX_CLOSE = "LIGHT_BOX_CLOSE", e.LIGHT_BOX_OPEN_BY_PHOTO_INDEX = "LIGHT_BOX_OPEN_BY_PHOTO_INDEX", e.LIGHT_BOX_MOVE_PHOTO_BY_INDEX = "LIGHT_BOX_MOVE_PHOTO_BY_INDEX", e))(Y || {});
const Pn = {
  photoIndex: 0,
  isOpen: !1
}, Rn = (e, t) => {
  switch (t.type) {
    case Y.LIGHT_BOX_OPEN:
      return { ...e, isOpen: !0 };
    case Y.LIGHT_BOX_CLOSE:
      return { ...e, isOpen: !1 };
    case Y.LIGHT_BOX_OPEN_BY_PHOTO_INDEX:
      return { isOpen: !0, photoIndex: t.payload };
    case Y.LIGHT_BOX_MOVE_PHOTO_BY_INDEX:
      return { isOpen: !0, photoIndex: t.payload };
    default:
      return e;
  }
};
const Lt = n.createContext(null), wn = ee("useCaptions", "CaptionsContext", Lt), Tn = ({ children: e }) => {
  const { subscribe: t } = q(), [o, r] = n.useState();
  n.useEffect(() => t("toolbar-width", (c) => {
    (!Re(c) || ie(c)) && r(c);
  }), [t]);
  const s = n.useMemo(() => ({ toolbarWidth: o }), [o]);
  return n.createElement(Lt.Provider, { value: s }, e);
}, J = (e) => O(`slide_${e}`), Sn = ({ description: e, descriptionTextAlign: t, descriptionMaxLines: o, styles: r }) => n.createElement(
  "div",
  { style: r.captionsDescriptionContainer, className: k(J("captions_container"), J("description_container")) },
  n.createElement("div", { className: J("description"), style: {
    ...t !== Ie.descriptionTextAlign || o !== Ie.descriptionMaxLines ? {
      style: {
        [M("slide_description_text_align")]: t,
        [M("slide_description_max_lines")]: o
      }
    } : null,
    ...r.captionsDescription
  } }, typeof e == "string" ? e.split(`
`).flatMap((s, c) => [...c > 0 ? [n.createElement("br", { key: c })] : [], s]) : e)
), Mn = ({ title: e, styles: t }) => {
  const { toolbarWidth: o } = wn();
  return n.createElement(
    "div",
    { style: t.captionsTitleContainer, className: k(J("captions_container"), J("title_container")) },
    n.createElement("div", { style: t.captionsTitle, className: J("title"), ...o ? { style: { [M("toolbar_width")]: `${o}px` } } : null }, e)
  );
}, Ie = {
  descriptionTextAlign: "start",
  descriptionMaxLines: 3
}, yn = ({ augment: e, addParent: t }) => {
  t(Ne, D(At, Tn)), e(({ render: { slideFooter: o, ...r }, captions: s, styles: c, ...l }) => ({
    render: {
      slideFooter: (d) => n.createElement(
        n.Fragment,
        null,
        o == null ? void 0 : o(d),
        d.title && n.createElement(Mn, { styles: c, title: d.title }),
        d.description && n.createElement(Sn, { styles: c, description: d.description, ...Ie, ...s })
      ),
      ...r
    },
    styles: c,
    ...l
  }));
}, Fn = yn, It = n.createContext(null), kn = ee("useFullscreen", "FullscreenContext", It), An = ({ children: e }) => {
  const t = n.useRef(null);
  return n.createElement(
    "div",
    { ref: t, className: k(O(xe), O(tt)) },
    n.createElement(It.Provider, { value: t }, e)
  );
}, Dn = j("EnterFullscreen", n.createElement("path", { d: "M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z" })), Bn = j("ExitFullscreen", n.createElement("path", { d: "M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z" })), Hn = ({ auto: e, labels: t, render: o }) => {
  var r;
  const [s, c] = n.useState(!1), [l, d] = n.useState(!1), i = kn(), _ = () => {
    var a, f, C, I;
    return (I = (C = (f = (a = document.fullscreenEnabled) !== null && a !== void 0 ? a : document.webkitFullscreenEnabled) !== null && f !== void 0 ? f : document.mozFullScreenEnabled) !== null && C !== void 0 ? C : document.msFullscreenEnabled) !== null && I !== void 0 ? I : !1;
  }, E = n.useCallback(() => {
    var a, f, C;
    return (C = (f = (a = document.fullscreenElement) !== null && a !== void 0 ? a : document.webkitFullscreenElement) !== null && f !== void 0 ? f : document.mozFullScreenElement) !== null && C !== void 0 ? C : document.msFullscreenElement;
  }, []), p = n.useCallback(() => {
    const a = i.current;
    if (a)
      try {
        a.requestFullscreen ? a.requestFullscreen().catch(() => {
        }) : a.webkitRequestFullscreen ? a.webkitRequestFullscreen() : a.mozRequestFullScreen ? a.mozRequestFullScreen() : a.msRequestFullscreen && a.msRequestFullscreen();
      } catch {
      }
  }, [i]), u = n.useCallback(() => {
    if (E())
      try {
        document.exitFullscreen ? document.exitFullscreen().catch(() => {
        }) : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.msExitFullscreen && document.msExitFullscreen();
      } catch {
      }
  }, [E]), m = n.useCallback(() => {
    l ? u() : p();
  }, [l, p, u]), h = n.useCallback(() => {
    E() === i.current ? d(!0) : d(!1);
  }, [i, E]);
  n.useEffect(() => (c(!0), () => c(!1)), []), n.useEffect(() => {
    const a = ["fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange"];
    return a.forEach((f) => {
      document.addEventListener(f, h);
    }), () => {
      a.forEach((f) => {
        document.removeEventListener(f, h);
      });
    };
  }, [h]);
  const v = P(() => {
    e && p();
  });
  if (n.useEffect(() => (v(), () => {
    u();
  }), [v, u]), !s || !_())
    return null;
  const b = (r = o.buttonFullscreen) === null || r === void 0 ? void 0 : r.call(o, { fullscreen: l, toggleFullscreen: m });
  return b === void 0 ? n.createElement(me, { label: l ? ae(t, "Exit Fullscreen") : ae(t, "Enter Fullscreen"), icon: l ? Bn : Dn, renderIcon: l ? o.iconExitFullscreen : o.iconEnterFullscreen, onClick: m }) : n.createElement(n.Fragment, null, b);
}, Vn = ({ augment: e, contains: t, addParent: o }) => {
  e(({ toolbar: { buttons: r, ...s }, ...c }) => ({
    toolbar: {
      buttons: [
        n.createElement(Hn, { key: xe, auto: Boolean(c.fullscreen), labels: c.labels, render: c.render }),
        ...r
      ],
      ...s
    },
    ...c
  })), o(t(Be) ? Be : Ne, D(xe, An));
}, Xn = Vn, zn = wt((e, t) => {
  const [o, r] = Tt(
    Rn,
    Pn
  ), { numOfImagesPerRow: s, imagesLightbox: c, lightBoxAdditionalProps: l } = e;
  St(
    t,
    () => ({
      openImageByIndex(_, E) {
        r({
          type: Y.LIGHT_BOX_OPEN_BY_PHOTO_INDEX,
          payload: _ === 0 ? E : E + _ * s
        });
      }
    }),
    [s]
  );
  const { photoIndex: d, isOpen: i } = o;
  return i ? /* @__PURE__ */ Rt(
    Nn,
    {
      close: () => r({ type: Y.LIGHT_BOX_CLOSE }),
      open: i,
      slides: c,
      index: d,
      plugins: [Fn, Xn],
      ...l
    }
  ) : null;
});
export {
  zn as ImagesLightBox,
  zn as default
};
